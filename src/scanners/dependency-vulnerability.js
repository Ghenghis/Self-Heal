/**
 * Dependency Vulnerability Scanner
 * 
 * Scans project dependencies for known vulnerabilities using multiple strategies:
 * 1. For npm projects: Uses npm audit
 * 2. For other projects: Checks against known vulnerability patterns
 * 3. Uses Claude AI to analyze dependencies for potential issues
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const { queryAI } = require('../ai');

class DependencyVulnerabilityScanner {
  constructor(projectPath, options = {}) {
    this.projectPath = projectPath;
    this.options = {
      autoFix: true,
      fixLevel: 'moderate', // none, low, moderate, high, critical
      maxVulnerabilities: 50, // Maximum number of vulnerabilities to report
      ...options
    };
    this.vulnerabilities = [];
  }

  /**
   * Main scanning method that orchestrates the vulnerability detection
   */
  async scan() {
    // Detect project type
    const projectType = this.detectProjectType();
    console.log(`Detected project type: ${projectType}`);

    // Scan based on project type
    switch (projectType) {
      case 'npm':
        await this.scanNpmProject();
        break;
      case 'pip':
        await this.scanPipProject();
        break;
      case 'maven':
        await this.scanMavenProject();
        break;
      case 'gradle':
        await this.scanGradleProject();
        break;
      default:
        await this.scanGenericProject();
        break;
    }

    // AI-powered analysis for all project types
    if (this.options.useAI) {
      await this.aiAnalysis(projectType);
    }

    return {
      count: this.vulnerabilities.length,
      vulnerabilities: this.vulnerabilities.slice(0, this.options.maxVulnerabilities),
      summary: this.generateSummary()
    };
  }

  /**
   * Detects the type of project based on files present
   */
  detectProjectType() {
    if (fs.existsSync(path.join(this.projectPath, 'package.json'))) {
      return 'npm';
    } else if (fs.existsSync(path.join(this.projectPath, 'requirements.txt'))) {
      return 'pip';
    } else if (fs.existsSync(path.join(this.projectPath, 'pom.xml'))) {
      return 'maven';
    } else if (fs.existsSync(path.join(this.projectPath, 'build.gradle'))) {
      return 'gradle';
    } else {
      return 'unknown';
    }
  }

  /**
   * Scans npm projects using npm audit
   */
  async scanNpmProject() {
    try {
      // Run npm audit and capture the output
      const auditOutput = execSync('npm audit --json', { 
        cwd: this.projectPath,
        stdio: ['ignore', 'pipe', 'pipe']  
      }).toString();
      
      // Parse the JSON output
      const auditResult = JSON.parse(auditOutput);
      
      // Process vulnerabilities
      if (auditResult.vulnerabilities) {
        Object.entries(auditResult.vulnerabilities).forEach(([pkgName, details]) => {
          this.vulnerabilities.push({
            type: 'dependency',
            package: pkgName,
            currentVersion: details.version,
            vulnerableVersions: details.range,
            severity: details.severity,
            title: details.title || 'Vulnerability detected',
            message: details.url || 'No details available',
            fix: {
              type: 'update',
              target: details.fixAvailable ? details.fixAvailable.version : 'latest',
              command: `npm update ${pkgName}${details.fixAvailable ? '@' + details.fixAvailable.version : ''}`,
              autoFix: this.canAutoFix(details.severity)
            }
          });
        });
      }
    } catch (error) {
      // Handle cases where npm audit fails or isn't available
      console.error('Error scanning npm dependencies:', error.message);
      
      // Fallback to package.json analysis
      await this.scanPackageJson();
    }
  }

  /**
   * Scans Python projects using pip
   */
  async scanPipProject() {
    try {
      // This would ideally use a Python security tool, but for demo we'll use a simplified approach
      const requirementsPath = path.join(this.projectPath, 'requirements.txt');
      const content = fs.readFileSync(requirementsPath, 'utf8');
      const dependencies = content.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'))
        .map(line => {
          // Parse name and version
          const match = line.match(/^([a-zA-Z0-9_.-]+)(.*)/);
          if (match) {
            return {
              name: match[1],
              version: match[2].trim() || 'latest'
            };
          }
          return null;
        })
        .filter(Boolean);

      // In a real implementation, we would check these against a vulnerability database
      // For this demo, we'll use a simulated check for common vulnerable packages
      const knownVulnerabilities = this.loadVulnerabilityPatterns('python');
      
      for (const dep of dependencies) {
        const vulnInfo = knownVulnerabilities.find(v => 
          v.packageName === dep.name && this.isVersionVulnerable(dep.version, v.vulnerableVersions)
        );
        
        if (vulnInfo) {
          this.vulnerabilities.push({
            type: 'dependency',
            package: dep.name,
            currentVersion: dep.version,
            vulnerableVersions: vulnInfo.vulnerableVersions,
            severity: vulnInfo.severity,
            title: vulnInfo.title,
            message: vulnInfo.description,
            fix: {
              type: 'update',
              target: vulnInfo.fixedVersion || 'latest',
              command: `pip install --upgrade ${dep.name}${vulnInfo.fixedVersion ? '==' + vulnInfo.fixedVersion : ''}`,
              autoFix: this.canAutoFix(vulnInfo.severity)
            }
          });
        }
      }
    } catch (error) {
      console.error('Error scanning Python dependencies:', error.message);
    }
  }

  /**
   * Scans Maven projects
   */
  async scanMavenProject() {
    // Similar implementation to scanPipProject but for Maven
    console.log('Maven project scanning not fully implemented');
  }

  /**
   * Scans Gradle projects
   */
  async scanGradleProject() {
    // Similar implementation to scanPipProject but for Gradle
    console.log('Gradle project scanning not fully implemented');
  }

  /**
   * Fallback scanner for npm projects that analyzes package.json directly
   */
  async scanPackageJson() {
    try {
      const packageJsonPath = path.join(this.projectPath, 'package.json');
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      // Combine dependencies and devDependencies
      const allDependencies = {
        ...(packageJson.dependencies || {}),
        ...(packageJson.devDependencies || {})
      };
      
      // Load known vulnerability patterns
      const knownVulnerabilities = this.loadVulnerabilityPatterns('javascript');
      
      // Check each dependency
      Object.entries(allDependencies).forEach(([name, versionRange]) => {
        const vulnInfo = knownVulnerabilities.find(v => 
          v.packageName === name && this.isVersionVulnerable(versionRange, v.vulnerableVersions)
        );
        
        if (vulnInfo) {
          this.vulnerabilities.push({
            type: 'dependency',
            package: name,
            currentVersion: versionRange,
            vulnerableVersions: vulnInfo.vulnerableVersions,
            severity: vulnInfo.severity,
            title: vulnInfo.title,
            message: vulnInfo.description,
            fix: {
              type: 'update',
              target: vulnInfo.fixedVersion || 'latest',
              command: `npm update ${name}${vulnInfo.fixedVersion ? '@' + vulnInfo.fixedVersion : ''}`,
              autoFix: this.canAutoFix(vulnInfo.severity)
            }
          });
        }
      });
    } catch (error) {
      console.error('Error scanning package.json:', error.message);
    }
  }

  /**
   * Generic scanner for unknown project types
   */
  async scanGenericProject() {
    console.log('Scanning project with generic vulnerability patterns');
    // This would scan for common vulnerable packages across different ecosystems
  }

  /**
   * Use Claude AI to analyze dependencies for vulnerabilities
   */
  async aiAnalysis(projectType) {
    try {
      // Prepare dependency lists based on project type
      let dependencies = [];
      
      switch (projectType) {
        case 'npm':
          try {
            const packageJson = JSON.parse(fs.readFileSync(path.join(this.projectPath, 'package.json'), 'utf8'));
            dependencies = [
              ...Object.entries(packageJson.dependencies || {}).map(([name, version]) => `${name}@${version}`),
              ...Object.entries(packageJson.devDependencies || {}).map(([name, version]) => `${name}@${version} (dev)`)
            ];
          } catch (e) {
            console.error('Error reading package.json:', e.message);
          }
          break;
        case 'pip':
          try {
            const requirements = fs.readFileSync(path.join(this.projectPath, 'requirements.txt'), 'utf8');
            dependencies = requirements.split('\n')
              .map(line => line.trim())
              .filter(line => line && !line.startsWith('#'));
          } catch (e) {
            console.error('Error reading requirements.txt:', e.message);
          }
          break;
        // Add similar cases for other project types
      }
      
      if (dependencies.length > 0) {
        const prompt = `
          Analyze these dependencies for potential security vulnerabilities:
          ${dependencies.join('\n')}
          
          For each vulnerability you find, provide:
          1. Package name
          2. Vulnerability description
          3. Severity (low, moderate, high, critical)
          4. Recommended fix
          
          Format your response as a JSON array of objects.
        `;
        
        const aiResponse = await queryAI(prompt);
        
        try {
          // Parse AI response as JSON (assuming it returns proper JSON)
          const aiVulnerabilities = JSON.parse(aiResponse);
          
          // Add AI-detected vulnerabilities to our list
          aiVulnerabilities.forEach(vuln => {
            this.vulnerabilities.push({
              type: 'dependency',
              package: vuln.packageName,
              currentVersion: vuln.currentVersion || 'unknown',
              severity: vuln.severity,
              title: vuln.title || 'AI-detected vulnerability',
              message: vuln.description,
              source: 'ai',
              fix: {
                type: 'update',
                target: vuln.recommendedVersion || 'latest',
                command: this.generateUpdateCommand(projectType, vuln.packageName, vuln.recommendedVersion),
                autoFix: this.canAutoFix(vuln.severity) && vuln.recommendedVersion
              }
            });
          });
        } catch (e) {
          console.error('Error parsing AI response:', e.message);
        }
      }
    } catch (error) {
      console.error('Error in AI analysis:', error.message);
    }
  }

  /**
   * Load known vulnerability patterns from the patterns directory
   */
  loadVulnerabilityPatterns(ecosystem) {
    try {
      const patternsPath = path.join(process.cwd(), 'patterns', 'dependency-vulnerabilities.json');
      if (fs.existsSync(patternsPath)) {
        const patterns = JSON.parse(fs.readFileSync(patternsPath, 'utf8'));
        return patterns[ecosystem] || [];
      }
    } catch (error) {
      console.error('Error loading vulnerability patterns:', error.message);
    }
    return [];
  }

  /**
   * Check if a version is vulnerable based on version range
   */
  isVersionVulnerable(currentVersion, vulnerableVersions) {
    // In a real implementation, this would use semver comparison
    // For this demo, we'll use a simplified check
    return vulnerableVersions.some(v => currentVersion.includes(v));
  }

  /**
   * Generate appropriate update command based on project type
   */
  generateUpdateCommand(projectType, packageName, version) {
    switch (projectType) {
      case 'npm':
        return `npm update ${packageName}${version ? '@' + version : ''}`;
      case 'pip':
        return `pip install --upgrade ${packageName}${version ? '==' + version : ''}`;
      case 'maven':
        return `mvn versions:use-next-releases -Dincludes=${packageName}`;
      case 'gradle':
        return `Use the latest version of ${packageName} in build.gradle`;
      default:
        return `Update ${packageName} to ${version || 'latest'}`;
    }
  }

  /**
   * Check if a vulnerability can be auto-fixed based on severity and settings
   */
  canAutoFix(severity) {
    if (!this.options.autoFix) return false;
    
    const severityRanking = {
      'low': 1,
      'moderate': 2,
      'high': 3,
      'critical': 4
    };
    
    const fixLevelRanking = severityRanking[this.options.fixLevel] || 0;
    const vulnLevelRanking = severityRanking[severity.toLowerCase()] || 0;
    
    return vulnLevelRanking >= fixLevelRanking;
  }

  /**
   * Generate a summary of the vulnerability scan
   */
  generateSummary() {
    // Count by severity
    const countBySeverity = {
      critical: 0,
      high: 0,
      moderate: 0,
      low: 0
    };
    
    this.vulnerabilities.forEach(vuln => {
      const severity = vuln.severity.toLowerCase();
      if (countBySeverity[severity] !== undefined) {
        countBySeverity[severity]++;
      }
    });
    
    // Count auto-fixable
    const autoFixable = this.vulnerabilities.filter(v => v.fix && v.fix.autoFix).length;
    
    return {
      total: this.vulnerabilities.length,
      countBySeverity,
      autoFixable,
      fixablePercentage: this.vulnerabilities.length > 0 
        ? Math.round((autoFixable / this.vulnerabilities.length) * 100) 
        : 0
    };
  }
}

module.exports = DependencyVulnerabilityScanner;